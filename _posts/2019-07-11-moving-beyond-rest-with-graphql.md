---
title: Moving Beyond REST with GraphQL
image: https://lh3.googleusercontent.com/B96QJu-GXsoSRj5Dzios_BmPZh2I-G695akVqonASUYANKRqOvhoa7nitcIkh2QgVXVhvxdmkoutXjXY7fCDv_dERJts8raA39CKh3xvoqK_AQJH3He4J2NHGzIqmo_CsEdJ2kciwD1fOX7lp6-oco5FXa35VztrZBW4jdrc7Fhds1d6aALu2omFhF4BAw7iwZ4YXM8IEvE_cPEj5V0XF_qAjAHF7cXHFLSwv3Izu0T3lo4N-r0LOieNSqROAogNJy1Bk50xRkacJEneF97iX5OnjzZGysD7982dvRrSVn9V-gGXJ3FsJRS_ntEHA5EIbQBxtdP7MaWRn4vsdSx9gkBevEpTfUylcSoNhhlSE8KI09FdkII168q5ELybWmcsRayANUmh6-_PhvjJQTBHNgONb2IONVpbwQuSlHQbaogtBV6ptu_217R7vCQyM9WDfxAq5QkMAA7GutQk3K-cckccgP96dP3w4EFR0mE128LvmCangxTZ7gaYQz3GK1gk2ki-o4y8Cokbv9sIqV3nybEhG1onklyuKceCFxYf_0vWOZVrM2QvQ9g-z03B9U5AUdEiB4ngpsI7hvax6r1MFdvw7RD_0msXYrq1SU5SxLfgoLNFv5F7MZUNe0VHXUHVhIvYETbXVs3W7W7bcdaNed0dRQRQZGpk-ANJQVS7LOQs40cyQtPgE_EJ50yo=w1958-h1640-no?authuser=0
author: Sergio Martin Rubio
categories:
    - Design Pattern
    - Data Query
    - Java Framework
mermaid: false
layout: post
---

[**GraphQL**](https://graphql.org/){:target="_blank"} is a **query language** that matches up with **Domain Driven Design**, so you can use your existing entities or models in your _GraphQL_ design.

This query language was created by _Facebook_ and open sourced later in 2015, and since then it has been maitained by the community.

To start using _GraphQL_ you will have to learn a new specification, because it is not a simple implementation, however it is pretty simple and if you are familiar with other query languages it will take you a few hours to understand how it works. Also the [GraphQL spec](https://graphql.github.io/graphql-spec/June2018/#){:target="_blank"} is very well documented and shows you how to use operations like queries or mutations, define schemas or what good practicies you should follow.

## How it works

This _API Query Language_ allows you to retrieve data from a service in one go. How can you do that? A single endpoint is exposed by _GraphQL_, and given a schema which contains your models and operations, you can make _HTTP_ requests to `/graphql` by providing operation names, a payload and variables. 

_GraphQL_ supports both, _GET_ and _POST_ _HTTP_ methods. In case of _GET_, we have to use a query parameter (`?query={operationName{field}}`). On the other hand, we could do a standard _POST_ request with a _JSON_ payload.

e.g.

```json
{
  "query": "...",
  "operationName": "...",
}
```

>Remember that URLs can only be sent over the internet using the _ASCII_ character-set.

## Operations
### Query

Queries are used to retrieved data, and you should use them to perform read operations in your service. Here there is an example:

```graphql
query {
  findHotelById(id: 2) {
      name
      address
      room {
          type
      }
  }
}
```

The _findHotelById_ is the operation of the query, and everything else inside the operation is called _payload_. You can use arguments like the one in the previos example (id: 2), that will return the Hotel with id 2.

Queries also support _dynamic_ arguments, and provides a way to pass them as JSON in the operation. You will use them like this:

```graphql
query MyQuery($hotelId:ID) {
  findHotelById(id:$hotelId) {
    name
    room {
      type
      occupants
    }
  }
}
```

```json
{
  "hotelId": "1"
}
```
>You could use the shorthand syntax and omit both the _query_ keyword and the _query name_, but it is a good practice to use these to make our code more readable, and they can be useful for debugging or identify different GraphQL requests.

In case you have to create a complex query you could use _Fragments_. Fragments are reusable blocks that contain a set of fields. For example:

```graphql
query MyQuery {
  firstHotel: findHotelById(id:1) {
    ...compareHotels
  }
  secondHotel: findHotelById(id:3) {
    ...compareHotels
  }
}

fragment compareHotels on Hotel {
    name
    room {
      type
      occupants
    }
}
```

>You have to use three dots followed by the fragment name to call a fragment.

### Mutation

**Mutations** are used to alter data and they should trigger insertions, updates or deletions in your database. You can create a mutation by replacing the _query_ with the _mutation_ keyword. This is an example:

```graphql
mutation {
  newHotel(name:"test 1", address: "test 1"){
    id
  }
}
```

Just like in queries, if a mutation returns an object type, you can ask for nested fields. In the previous example the mutation creates a new _Hotel_ and returns the _id_ for the created _hotel_, which was in this case autogenerated.

>Apart from sintax, queries and mutations differ from each other on one more thing, query fields are executed in parallel, whereas mutations run sequencially.

### Subscription

_GraphQL_ _subscriptions_ are a way to **stream data** from the server to the clients that are listening. In the same way as queries, subscriptions allow you to ask for a set of fields, but instead of making a stateless _HTTP_ request, a **websocket connection is used to have a stream of data coming from the server, so that every time there is a change on the server, results are sent to the client, or in other words, when a client runs a _mutation_ the subscription is triggered.

>"Executing a _subscription_ creates a persistent function on the server that maps an underlying Source Stream to a returned Response Stream."

`/subscriptions` is by default the **WebSocket** subscriptions endpoint. Here's an example of _Javascript_ client using subscriptions:

```javascript
function subscribeToHotels() {
    let socket = new WebSocket("ws://localhost:8080/subscriptions");

    socket.onopen = function () {
        let query = `
              subscription MySubscription {
                getNewHotel {
                  name
                  address
                  creationDate
                }
              }
        `;
        let graphqlRequest = {
            query: query,
            variables: {}
        };
        socket.send(JSON.stringify(graphqlRequest));
    };
    socket.onmessage = function (event) {
      // handle response
    }
}
```

## Schema

Schema files are text files with `.grapqhl` extension. Operations and models are define there, and in order to do that _GraphQL_ provides a schema language which inclues scalar types, markers and other keywords to build complex schemas 

Built-in scalar types are:

| **GraphQL Type**        | **Serialized as**      |
| ------------- |:-------------:|
| **Int**     | Signed 32‐bit integer |
| **Float**      | Signed double-precision floating-point value      |
| **String** | UTF‐8 character sequence      |
| **Boolean** | true or false      |
| **ID** | String      |

Type Markers:

| **GraphQL Marker**        | **Equivalent**     |
| ------------- |:-------------:|
| `<type>!`     | Not Null |
| `[<type>]`     | List      |
| `[<type>!]` | List of Not Null Elements      |
| `[<type>]!` | Not Null list      |
| `[<type>!]!` | Not Null list of Not Null Elements      |

Here you have an example:

```graphql
type Hotel {
    id: ID!
    ## Hotel name
    name: String!
    ## Hotel address
    address: String!
    ## Date of the hotel registry creation
    creationDate: String!
    ## List of rooms for a particular hotel
    room: [Room]!
}
```

>You can also add comments to document your schema, and to do so, you just need to add them before each field, type or argument.

_Queries_, _mutations_ and _subscriptions_ can be created as follows:

```graphql
## The Root Query for the application
type Query {
    ## Retrieves all hotels
    findAllHotels: [Hotel]
    ## Retrieves a Hotel given an ID (eg: '1, 4, 12')
    findHotelById(id: ID): Hotel
    ## Number of Hotel available
    countHotels: Int
    ## Finds all payment methods
    findAllPayments: [Payment]
}
```

You just need to define the name of the operation with optional parameters followed by the returned type.

_Query_, _Mutation_ and _Subscription_ keywords are used as the root of each type of operation for the application. But it is easy to add additional operations by using the `extend` keyword. e.g.

```graphql
extend type Query {
    foos: [Foo]!
}
```

>_Custom types_ are also extendible to avoid large list of fields.

There are also other more advance elements like `interface`, `union`, `enum` or `scalar`.

## How to create a GraphQL Spring Boot Server?

We need to:

1. Define _GraphQL Schema_.
2. Decide how the data for a query is fetched.

### Define GraphQL Schema

Here there is an example:

{% gist 9e6069efb65747a6ef9e1993dfb1733c schema.graphql %}

There is a [Java GraphQL tool library](https://github.com/graphql-java-kickstart/graphql-java-tools#why-graphql-java-tools){:target="_blank"} that parses your schema to _Java_ and configure classes for creating a `GraphQLSchema`. 

>By default _GraphQL_ tools uses the location pattern `**/*.graphqls` to scan for _GraphQL_ schemas on the classpath.

```xml
<dependency>
    <groupId>com.graphql-java</groupId>
    <artifactId>graphql-java-tools</artifactId>
    <version>5.2.4</version>
</dependency>
```

### Build Spring Boot application

These two libraries are required to start using _GraphQL_ with _Spring_, and basically there are setting up the servlet:

```xml
<properties>
  <kotlin.version>1.3.10</kotlin.version>
</properties>

<dependencies>
    ...
    <dependency>
        <groupId>com.graphql-java</groupId>
        <artifactId>graphql-java</artifactId>
        <version>11.0</version>
    </dependency>
    <dependency>
        <groupId>com.graphql-java</groupId>
        <artifactId>graphql-spring-boot-starter</artifactId>
        <version>5.0.2</version>
    </dependency>
</dependencies>
```

The first one is the _GraphQL_ _Java_ implementation, while the second one makes available the servlet at `/graphql`.

>`graphl-java-tools` requires `kotlin.version` Kotlin 1.3.10, because _Spring Boot Starter_ parent currently overrides it with a 1.2.* version of _Kotlin_. _Spring Boot_ team has indicated the _Kotlin_ version will be upgraded to 1.3 in _Spring Boot 2.2_.


For this example MongoDB is used as the repository, since to allow real time updates with [Reactive Programming](https://sergiomartinrubio.com/articles/quick-introduction-to-reactive-programming) and _GraphQL_ Subscription.

```java
public interface HotelRepository extends ReactiveCrudRepository<Hotel, String> {
    @Tailable
    Flux<Hotel> findWithTailableCursorBy();
}
```

>`@Tailable` is required to query capped collections in MongoDB. Capped collections will keep the cursor open even after reaching the end of the collection.

The next step is to create resolvers for each object defined in your schema. _Query_, _Mutation_ and _Subscription_ are root _GraphQL_ objects, and you need to implement `GraphQLQueryResolver`, `GraphQLMutationResolver` and `GraphQLSubscriptionResolver` respectively so that `graphql-java-tools` will be able to map the _GraphQL_ operations with the methods created in the resolvers. Here there is an example:

```java
@Component
@RequiredArgsConstructor
public class Query implements GraphQLQueryResolver {

    private final HotelRepository hotelRepository;
    private final PaymentRepository paymentRepository;

    public Iterable<Hotel> findAllHotels() {
        return hotelRepository.findAll().toIterable();
    }

    public Optional<Hotel> findHotelById(String id) {
        return hotelRepository.findById(id).blockOptional();
    }

    public Optional<Long> countHotels() {
        return hotelRepository.count().blockOptional();
    }

    public Iterable<Payment> findAllPayments() {
        return paymentRepository.findAll().toIterable();
    }
}
```

>Method name and signature have to match with GraphQL the corresponding operation definition.

Additionally, you might need to create resolvers for nested fields. 

e.g.

```java
@Component
@RequiredArgsConstructor
public class HotelResolver implements GraphQLResolver<Hotel> {

    private final RoomRepository roomRepository;

    public Iterable<Room> getRoom(Hotel hotel) {
        return roomRepository.findAllByHotelId(hotel.getId()).toIterable();
    }
}
```

In the previous example, when hotels are retrieved and rooms might be retrieved as well, therefore a method to retrieve rooms by hotel ID needs to be provided.

<p class="text-center">
{% include elements/button.html link="https://github.com/smartinrub/spring-reactive-mongo-graphql" text="Source Code" %}
</p>

### GraphiQL, a GraphQL client

_GraphiQL_ is a very useful tool to explore your _GraphQL_ schema and make requests. The most simple way to start using _Graphiql_ is by adding to your `pom.xml` file as a dependency.

```xml
<dependency>
    <groupId>com.graphql-java-kickstart</groupId>
    <artifactId>graphiql-spring-boot-starter</artifactId>
    <version>5.7.0</version>
</dependency>
```

By default you can hit it at `/graphiql`.

### Highlights and Challenges

- The main benefit of using _GraphQL_ is that you get what you ask for in a single request, whereas with _REST_ we tend to do "overfetching" or "underfetching".

- _GraphQL_ can also be simpler and faster, however you may face unpredictable performance when multiple fields are combined.

- One of the challenges is versioning. You will have to deprecate fields and will not be able to know if a field has changed over time.

- Another point against _GraphQL_ is caching. In _GraphQL_, you cannot use URLs as cache identifiers, so you need to create unique keys and implement caching in your application.

- There is also an extra overhead, since the server needs to do more processing to parse the query and verify parameters.

- Lastly, in case of a simple API the extra complexity added by GraphQL is not worth.

### Conclusion

_GraphQL_ is similar to an API gateway or proxy server that sits in front of your downstream services or data sources, and just like _HTTP_ we can use verbs to get exactly what we ask for. It is also an alternative to _REST_, _SOAP_ or _gRPC_, but this does not mean you have to through away your current architecture, for instance you could have _GraphQL_ on top of your _REST_ services.

This technology is becoming more mature and is available for multiple languages, including _JavaScript_, _Python_, _Ruby_, _C#_, _Go_, _Scala_ or _Java_, and companies like _Pivotal_ are heavily supporting _GraphQL_. In fact it was one of the topics presented in [Spring IO 2019](https://2019.springio.net/sessions/moving-beyond-rest-graphql-and-java-spring){:target="_blank"}. 
